Working on -  2 EVENT buttons need mapped - Refund options and view Booking Details

Partial refund complete- need todo FULL REFUND then thats it for mapping 
Full Refund needs Confirmation message  - ON Both CAMP AND EVENT

Notifications


------------

ADMIN settings- Set Camp price per day
ANDROID FULL TEST - Date TIME picker and dropdown CHecks , some componets might not work .

Things to tidy up , replace all buttons so that onPress is on the TouchableOpacity not the text

Enquiry about an Event 

OFFERs - 2 For price of 3 - Use a discountCode? or pick it up itself if this camp has that offer






Camps in the past should not be able to BOOK 


// NEED CHeCKS around deleting camps in case of user error. Recycle them ? 

Upcoming Booking Screen - 
MODAL - CANCEL / Refund request-  Reason input and info say its sent to admin could take up to 7 days to refund if accepted we will update you. Please Contact us for further info 
--- Notify ADMIN USER -- SAVE Record of Request and reason + we need a date and time of when the request was sent 
-- notify the user with the outcome / Status 
We would need to use the date time so that dont see past event Bookings


Create Display so that ADMIN can see all who has made Booking  

Dashboard -We would need to use the date time so that dont see past event Bookings

Log out btn


Event bookings need tied into MyBookings 
------------

NOTES of things todo / research 

 CRM Book / PaymentStripe
 -- GO live CheckList - Research 

--------

Questions




Offers - 
Admin - Set offer 

Add to names = Special offer (boolean)
Calendar 






Dropdown option - Choose a person then we delete that record as with the above option we cant determine which particpants record. 

Full refund Button -> Send a Notification Record to the ADMIN -> ADMIN Then logs in and can see the requests and 
then they must go onto Stripe to refund. 

---





---------------------
ADD STRIPE API KEY TO PROCESS ENV UPDATE CODE 
CRM - Manage Booking / Cancel / refund

Fix Create camp Front end 

CRM - Previous booking - Request refund button - send Notification to Admin 

Any REQUIRED FIeLDS ON CREATEBOOKING  - Contact number?

booking Detials -

Notifications
API keys and MongoDB needs protected in env 

Ability to view all particants in that CAMp that have booked and click on their profile to see contact detials if needed.

Auth routes 
unauth Routes 

CLear console logs of JWT token 

----
SIGN UP - CUSTOMER



----
Make BOOKING   / Checkout questions  - (CRM ONLY)
Has your child have any disablities or alergies ** State 
we do not store allegies / disablities only until the event / camp is over.
      //Update Array with record  - We will not be updating the DB until after the payment?? 

-----

Manage bookings (ADMIN ONLY)

Edit Camp / Event - Need to maintain Time and date and price all values and the user has the option to edit whatever so i think we will be PUT all 
Delete Camp / Event - DONE

------


Add to BASKET and return back later or just have it for now just have to reenter?



Logout Button



------
Admin View  -- 

This where they will be able to add / Delete upcoming events and add Payment links with Stripe
Create event
Create a Camp  
Manage bookings 

Test needed on Andriod to confirm that all modules work on Andriod/ ios / web - mainly the date picker
Andriod date time not sure if working or coded right , will need to test
Handlesubmit within createcamp is only tested in ios unsure about Andriod yet 
------



put MongoDB URL in .env file 



----
CRM view   -- 
there will be Stripe links created
Booking into a Camp
Book into an event
Enquiry about a birthday / This is not a guareented commitment just suggest / notify The ADMin that the user would like to book a bday party etc 
Notifications when Event/Camp is created , different alerts to device 
-----


Terms and conditions 

Knowledge of the app / Workings 

Stripe
NEED TO PUT KEYS IN ENV file , cant get it working at the min


Refunds can be processed on the Stripe Application - To be tested
We can implement refunds on the app but that could be a future feature / Release 
For now i think we could have it that the User can see previous Camps / Events within the last X days 
and then request a refund then the business would log in and see the nofication and go on the Stripe application and process
how do we tell the outcome - Notifications ?  


refunds


APPLE PAY SETUP - SO THIS WILL ONLY BE ABLE TO ACCESSed when we get a merchantID , We will first do card only as this is main form and also Dev Program is £99 and i was having issues getting this setup we will fix this in the future 

Merchant ID 
If your app is being built for a specific client and they will take over the app once it's live, you have a couple of options regarding the Apple Merchant ID:

You Keep Ownership, But Integrate with Their Stripe Account: If you continue to own and maintain the app on behalf of the client, you can keep your Apple Merchant ID and integrate with the client's Stripe account. In this scenario, the client provides you with their Stripe publishable key and other necessary credentials, and you update the Stripe configuration in your app accordingly.
Client Assumes Full Ownership: If the client will assume full ownership of the app, including the Apple Developer account and any related credentials, they will need to create their own Apple Merchant ID and integrate with their own Stripe account. Once they have their own credentials, they will need to update the Stripe configuration in the app before taking it live.
The approach you choose depends on the agreement with your client and how ownership and maintenance of the app are being structured. It's essential to clarify this with your client and determine the best course of action before deploying the app live.


publishableKey: This is your Stripe publishable key, which you get from your Stripe Dashboard. It's used to identify your account with Stripe and authenticate API requests from your app. This is required for integrating with Stripe.
merchantIdentifier: This is an identifier provided by Apple when you set up Apple Pay in your Stripe account. It's used to configure Apple Pay for your app. If you're not setting up Apple Pay, you can omit this property or set it to undefined.
urlScheme: This is a custom URL scheme for your app, which is used for deep linking and handling redirects. You can set this to a unique value for your app (e.g., your-app-name://), but it's optional unless you're setting up Apple Pay.



---
CREATE A CAMP - Admin ONLY



---

TESTING PAYMENTS 
GO LIVE CHECKLIST
https://docs.stripe.com/development/checklist

PAYMENT METHOD	SCENARIO	HOW TO TEST

Credit card	The card payment succeeds and doesn’t require authentication.	Fill out the credit card form using the credit card number 4242 4242 4242 4242 with any expiration, CVC, and postal code.
Credit card	The card payment requires authentication.	Fill out the credit card form using the credit card number 4000 0025 0000 3155 with any expiration, CVC, and postal code.
Credit card	The card is declined with a decline code like insufficient_funds.	Fill out the credit card form using the credit card number 4000 0000 0000 9995 with any expiration, CVC, and postal code.
Credit card	The UnionPay card has a variable length of 13-19 digits.	Fill out the credit card form using the credit card number 6205 500 0000 0000 0004 with any expiry date, CVC, and postal code.




import React, { useEffect, useState } from 'react';
import { ScrollView,StyleSheet, View, TextInput, Button, Text, TouchableOpacity, Modal,FlatList, Alert } from 'react-native';
import validator from 'validator';
import { useNavigation } from '@react-navigation/native';
import AsyncStorage from '@react-native-async-storage/async-storage';

import DropDownPicker from 'react-native-dropdown-picker';



const MyBookings = ({ navigation }) => {

      const [isLoggedIn, setIsLoggedIn] = useState(false);
      const [bookingData, setBookingData] = useState([]);
      const [campData, setCampData] = useState([]);
      const [eventData, setEventData] = useState([]);
      const [bookingCampData, setBookingCampData] = useState([]);
      const [bookingEventData, setBookingEventData] = useState([]);
      const [refundReason , setRefundReason] = useState('');

   
      
      const [selectedParticipants, setSelectedParticipantsArray] = useState([]);
    
      const [refundReasonErrorMessage , setRefundReasonErrorMessage] = useState('');
      const [refundModalVisible, setRefundModalVisible] = useState(false);


      const [refundConfirmationModalVisible, setRefundConfirmationModalVisible] = useState(false);
     

      useEffect(() => {


        const checkAuthentication = async () => {
          try {
            const jwtToken = await AsyncStorage.getItem('jwtToken');
            setIsLoggedIn(!!jwtToken);
    
          
          } catch (error) {
            console.error('Error fetching JWT token:', error);
          }
        };
        const fetchData = async () => {
          try {
            const jwtToken = await AsyncStorage.getItem('jwtToken');
            setIsLoggedIn(!!jwtToken);
    
            // Fetch booking data
            const apiGetBookings = 'http://localhost:3000/api/getBookingRecords';
            const bookingsResponse = await fetch(apiGetBookings, {
              method: 'GET',
              headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${jwtToken}`,
              },
            });
            if (!bookingsResponse.ok) {
              Alert.alert("You do not have any bookings.")
              //throw new Error('Network response was not ok');
            }
            const bookingData = await bookingsResponse.json();
            setBookingData(bookingData);
          
    
            // Fetch and process camp data
            const apiGetCamps = 'http://localhost:3000/api/camps';
            const campsResponse = await fetch(apiGetCamps, {
              method: 'GET',
              headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${jwtToken}`,
              },
            });
            if (!campsResponse.ok) {
              Alert.alert("You do not have any bookings.")
             // throw new Error('Network response was not ok');
            }
            const campsData = await campsResponse.json();
            setCampData(campsData);
          
            // Process booking data
            processBookings(bookingData, campsData);
          } catch (error) {
            console.error('Error fetching data:', error);
          }
        };
    
        fetchData(); // Fetch data when component mounts
      }, []);
    
      const processBookings = (bookingData, campData) => {
         // Extract unique camp IDs from bookingData
          const uniqueCampIDs = Array.from(new Set(bookingData
            .filter(item => item.bookingType === 'Camp') // Filter bookingData to include only bookings of type 'Camp'
            .map(item => item.campID))); // Map to get an array of campIDs and then create a set to get unique IDs

          // Map over unique camp IDs to find corresponding camp objects
          const bookingCampData = uniqueCampIDs.map(campID => {
            // Find the camp object with the current campID
            const foundCamp = campData.find(camp => camp._id === campID);
            // If a camp is found, return it; otherwise, return null
            return foundCamp ? foundCamp : null;
          });

          // Set the state with the processed bookingCampData
          setBookingCampData(bookingCampData);

         
      };

    // Function to close the modal 
      const closeRefundModal = () => {
      setRefundModalVisible(false);

    };

     // Function to close the modal 
     const closeRefundConfirmationModal = () => {
      setRefundConfirmationModalVisible(false);

    };

    const openRefundConfirmationModal = async() => {

      //Validation Check - Reason is a required Entry
      if(refundReason == "")
      {
        //Validation message 
        const reasonValidationMessage = "Please enter a reason"
        setRefundReasonErrorMessage(reasonValidationMessage);
      }
      else{

        if(value == [])
        {
          const reasonValidationMessage = "Please select at least 1 particant"
          setRefundReasonErrorMessage(reasonValidationMessage);
        } 
        else{


       

          setSelectedParticipantsArray(selectedBookingRecord.participantArray);

          setRefundModalVisible(false);
          setRefundConfirmationModalVisible(true); 

        }

      }

 
    };



    const RequestRefundCancellationModalVisible = async(booking) => {
       
        setSelectedBookingRecord(booking);
        setRefundModalVisible(true);
    };




      const RequestPartialRefund = async() => {

        setRefundConfirmationModalVisible(false);
        //Validation Check - Reason is a required Entry
        if(refundReason == "")
        {
          //Validation message 
          const reasonValidationMessage = "Please enter a reason"
          setRefundReasonErrorMessage(reasonValidationMessage);
        }
        else{

          if(value == [])
          {
            const reasonValidationMessage = "Please select at least 1 particant"
            setRefundReasonErrorMessage(reasonValidationMessage);
          } 
          else{

            // Update Status so that it changes on the Record from Booked to Partial Refund Request Sent 
            // Update Person AttendanceStatus value 
  
              const jwtToken = await AsyncStorage.getItem('jwtToken');

          
                    try {
                        const response = await fetch(`http://localhost:3000/api/updateBookingRecord/${selectedBookingRecord._id}`, {
                            method: 'PUT',
                            headers: {
                                'Content-Type': 'application/json',
                                'Authorization': `Bearer ${jwtToken}`,
                            },
                            body: JSON.stringify({
                              // Include the data you want to send in the body
                              // For example:
                              _id: selectedBookingRecord._id,
                              participantID: value,
                              reasonForRefund: refundReason
                              // Other properties...

                          })
                           
                        });


       // Notify Admin  HERE WHEN WE GET THE notifacatins ? ? 
      
                    
                        const updatedRecord = await response.json();
                      
                        if(updatedRecord == null)
                        {
                          setRefundModalVisible(true);
                        }
                        else{
                          
       
                          setRefundModalVisible(false);
                          navigation.navigate('DashboardCRM');
                        }

                        if (!response.ok) {
                          throw new Error('Failed to update booking record');
                        }
                        // Handle successful update
                      } catch (error) {
                        console.error('Error updating booking record:', error);
                        // Handle error
                      }
    
                      
          
                   
                }
                  }
            }



          


     



              // How do we update list of attendance and have a (Partial Refund Request sent)

            // PUT 


            // obtain index if the the array booking 



            
            // Where will we update ParticipantsBooked Array? as they shouldnt update until after refund is confirmed by ADMIN 
          

            // Create a Provisional Record which will then become the Primary record if the Partial Record is successful? 
              
          
         // }
    
           
              // Create a Provisional Record which will then become the Primary record if the Partial Record is successful? 
              
              // Send Message to Admin

              // Create Refund Record for Admin to review 

              // Close Modal 

              // Update Status : Partial Refund Requested

        
      


        // Create refund Record for Admin to review 

        // Close Modal 

        // Update Status : Partial Refund Requested

      //  }

     // };

     

      const RequestedFullRefund = async() => { 

        //Validation Check - Reason is a required Entry 
        // IF Populated allow user to submit 
        // Else update validationMessage 

        // Send Message to Admin

        // Create refund Record for Admin to review 

        // Close Modal 

        // Update Status : Partial Refund Requested



      };



    
   

// Define initial values
const initialValue = []; // Provide an initial value for 'value' state
const initialItems = []; // Provide an initial value for 'items' state

const [open, setOpen] = useState(false);
const [value, setValue] = useState(initialValue);
const [items, setItems] = useState(initialItems);

const [selectedBookingRecord, setSelectedBookingRecord]= useState();
const [selectedParticipantID, setSelectedParticipantID] = useState(initialValue);






// Usage example of setValue
const updateValue = (newValue) => {
  setValue(newValue);
};

// Usage example of setItems
const updateItems = (newItems) => {
  setItems(newItems);
};

const renderParticipantItem = ({ item: participant }) => (
  <View style={{ marginTop: 10 }}>
    <Text>Participant Name: {participant.name}</Text>
    <Text>Participant Age: {participant.age}</Text>
    <Text>Participant Allergies: {participant.allergies || 'None'}</Text>
    {participant.daysSelectedArray.length > 0 ? (
      <View>
        <Text>Selected Days:</Text>
        <FlatList
          data={participant.daysSelectedArray}
          keyExtractor={(day, index) => index.toString()}
          renderItem={({ item: day }) => (
            <Text key={day}>{day}</Text>
          )}
        />
      </View>
    ) : (
      <Text>No selected days</Text>
    )}
  </View>
);







return (





<ScrollView>
   Check if either bookingCampData or bookingData is undefined
   {(!bookingCampData || !bookingData) ? (
        <Text>Please make a booking</Text>
      ) : (
        <View>
  {bookingCampData.map((camp, index) => (
    <View key={index} style={styles.container}>  
      <Text>{camp.campName} </Text>
      <Text>Location: {camp.location}</Text> 
      <Text>Duration: {new Date(camp.startDate).toLocaleDateString('en-GB')} - {new Date(camp.endDate).toLocaleDateString('en-GB')}</Text>
      <Text>Start Time: {new Date(camp.startTime).toLocaleTimeString()} - End Time: {new Date(camp.endTime).toLocaleTimeString()}</Text>



      {/* Iterate over bookings associated with this camp */}
      {bookingData.filter(booking => booking.campID === camp._id).map((booking, bookingIndex) => (
        <View key={bookingIndex}>
          <Text>Status: {booking.bookingStatus}</Text>
          <Text>Booking ID: {booking._id}</Text>
          <Text>Participants: {booking.participantsBooked}</Text>
          <Text>Price: £{booking.totalPrice}</Text>

          <View style={{ flex: 1, padding: 20 }}>
              {/* Render participant details for each booking */}
              {/* <FlatList
                  data={booking.participantArray}
                  keyExtractor={(participant, index) => index.toString()}
                  renderItem={renderParticipantItem}
              /> */}
          </View>

   
  
            {/* Render other camp details */}
            <TouchableOpacity style={styles.button1} onPress={() => RequestRefundCancellationModalVisible(booking)}>
              <Text style={styles.buttonText}>View Refund Options</Text>
            </TouchableOpacity>


          </View>
          
      
    ))}

    </View>
      ))}
      </View>
      )}

     {/* )} */}
      

          {/* Modal  */}
          <Modal
            animationType="slide"
            transparent={true}
            visible={refundModalVisible}
            onRequestClose={closeRefundModal}

          >
            <View style={styles.modalContainer}>
              <View style={styles.modalContent}>
                <View style={{ flexDirection: 'column' }}>
                  <Text style={styles.label}>Reason for cancellation / Refund request: *</Text>
                  <Text style={styles.validationText}>{refundReasonErrorMessage}</Text>
                  <TextInput
                    style={styles.textInput}
                    placeholder='Enter here..'
                    onChangeText= {(text) => setRefundReason(text)}
                  />
                </View>

                <View style={{ flexDirection: 'column' }}>
                  <Text>Please select the participants you would like to request to refund / cancel or Press the "Full Refund" button to request a full refund</Text>
                </View>

                {/* Participant selection */}
                <View style={styles.dropdownContainer}>
                  <Text style={styles.label}>Participant lists</Text>
                   {/* Dropdown for selecting participant */}
                  <View style={styles.dropdownContainer}>
                    <DropDownPicker
                      open={open}
                      value={value}
                      setOpen={setOpen}
                      setValue={updateValue}
                      setItems={updateItems}
                      placeholder={'Choose a participant'}
                      multiple={true}
                      mode="BADGE"
                      badgeDotColors={["#e76f51", "#00b4d8", "#e9c46a", "#e76f51", "#8ac926", "#00b4d8", "#e9c46a"]}


                      items={selectedBookingRecord?.participantArray.map(participant => ({ 
                        label: participant.name, 
                        value: participant._id 
                      })) || []}
                      containerStyle={styles.dropdown}
                    />
                  </View>
                  
                 </View>

              <View>
              {value.length > 0 && (
                  <View>
                              <View style={styles.buttonContainer}>
                                    <TouchableOpacity style={styles.button1} onPress={openRefundConfirmationModal}>
                                      <Text style={styles.buttonText}>Request Partial Refund</Text>
                                    </TouchableOpacity>
                                </View>

                                <View style={styles.buttonContainer}>
                                  <TouchableOpacity style={styles.button1} onPress={RequestedFullRefund}>
                                    <Text style={styles.buttonText}>Request Full Refund</Text>
                                  </TouchableOpacity>
                                </View>

                                <View style={styles.buttonContainer}>
                                  <TouchableOpacity style={styles.button1} onPress={closeRefundModal}>
                                    <Text style={styles.buttonText}> Exit</Text>
                                  </TouchableOpacity>
                                </View>

                 </View>

              )}

                {value.length <=0 && (
             

                          <View>
                               <View style={styles.buttonContainer}>
                                  <TouchableOpacity style={styles.button1} onPress={RequestedFullRefund}>
                                    <Text style={styles.buttonText}>Request Full Refund</Text>
                                  </TouchableOpacity>
                               </View>
                            
                               <View style={styles.buttonContainer}>
                                  <TouchableOpacity style={styles.button1} onPress={closeRefundModal}>
                                    <Text style={styles.buttonText}>Exit</Text>
                                  </TouchableOpacity>
                               </View>
                          </View> 


               )} 

                              </View>

                             </View> 
                      </View>
                                              
                     </Modal> 
                      
  


                        <Modal
                          animationType="slide"
                          transparent={true}
                          visible={refundConfirmationModalVisible}
                          onRequestClose={closeRefundModal}

                        >
                        <View style={styles.modalContainer}>
                                    <View style={styles.modalContent}>
                                      <View>
                                      <View style={styles.buttonContainer}>

                                      <Text style={styles.label}> Are you sure you want to request a refund?</Text>
                                          <TouchableOpacity style={styles.button1} onPress={RequestPartialRefund}>
                                            <Text style={styles.buttonText}>Yes</Text>
                                          </TouchableOpacity>
                                      </View>
                                    
                                      <View style={styles.buttonContainer}>
                                          <TouchableOpacity style={styles.button1} onPress={closeRefundConfirmationModal}>
                                            <Text style={styles.buttonText}>No</Text>
                                          </TouchableOpacity>
                                      </View>
                        </View> 

                      </View>
                </View>
                          


          </Modal>
                            
        


          </ScrollView>

                   
        
      );
    };
    
    const styles = StyleSheet.create({
      container: {
        borderWidth: 2,
        borderColor: '#ccc',
        padding: 20,
        margin: 20,
        width: 'auto',
      },
      validationText: {
        fontSize: 20,
        marginBottom: 10,
        color: 'red',
      },
      rowContainer: {
        flexDirection: 'row',
        alignItems: 'center',
      },
      columnContainer: {
        flexDirection: 'column',
        alignItems: 'center',
      },
       modalContainer: {
          flex: 1,
          justifyContent: 'center',
          alignItems: 'center',
          backgroundColor: 'rgba(0,0,0,0.5)',
        },
        modalContent: {
          backgroundColor: '#fff',
          padding: 20,
          borderRadius: 10,
           width: '80%',
        },
        fieldRow: {
          flexDirection: 'row',
           marginTop: 15,
           marginBottom: 10,
        },
        label: {
          // marginBottom: 5,
          fontWeight: 'bold',
        },
        textInput: {
          borderWidth: 1,
          borderColor: 'gray',
          padding: 10,
          marginTop: 10,
          marginBottom: 10,
        },
        buttonContainer:{
          marginTop:30
        },
        button: {
          backgroundColor: '#4CAF50',
          borderRadius: 4,
          padding: 10,
          marginBottom: 5,
          
        },
        button1: {
          backgroundColor: '#4CAF50',
          borderRadius: 4,
          padding: 10,
          zIndex: 2, // Ensure dropdown is above other elements
          marginBottom: 5,
         
        },
        buttonText: {
          color: 'white',
          fontSize: 16,
          textAlign: 'center',
        },
        containerd: {
          flex: 1,
          justifyContent: 'center',
          alignItems: 'center',
        },

        dropdownContainer: {
          position: 'relative',
          marginBottom: 30, // Adjust this value as needed to prevent overlap
          zIndex: 1, // Ensure dropdown is above other elements
        },
        dropdown: {
           position: 'absolute',
          zIndex: 1, // Ensure dropdown is above other elements
          width: '100%',
        },
        
    });
    
    export default MyBookings;






